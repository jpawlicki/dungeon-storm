<html>
<head>
	<!--
		The game state is kept as JSON object of the following structure:
		{
			state_count: 1
			map_bounds: {
				w: 32,
				h: 32,
			},
			contents: [
				{id: 21, type: "wall", x: 12, y: 13},
				{id: 21, type: "dwarf", x: 11, y: 12, moves: 5, facing: "N"},
				{id: 21, type: "dwarf", x: 14, y: 16, moves: 3, facing: "S"},
			],
			phase: {
				turn: 'defender' || 'attacker' || 'defender_fire' || 'attacker_fire'
			},
		}

		This object is shared between all clients.
		Clients have code to compute the difference between two states.
		These differences are then turned into UI instructions; i.e. move item from A to B on the map.
		The UI also have controls which issue 'orders'.
		Orders are simply updates of the game state.

		A dumb server synchronizes the state between clients.
		Each client is responsible for checking that the state transitions are legal.
		A fair source of randomness can be implemented using a hashing/mixing scheme. For now we'll
		just trust clients.

		Most UI is SVG-based, and the SVG subsystem can handle animating transitions to make the
		variations in state better.

		state_count must be incremented with each commit to the server. The server prevents races
		by rejecting commits that don't increment the server-recognized state by 1.
	-->
	<script>
		var state = {};
		var c
	</script>
</head>
<body>
</body>
</html>
